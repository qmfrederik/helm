// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: hapi/services/tiller.proto
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Hapi.Services.Tiller {

  /// <summary>Holder for reflection information generated from hapi/services/tiller.proto</summary>
  public static partial class TillerReflection {

    #region Descriptor
    /// <summary>File descriptor for hapi/services/tiller.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static TillerReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChpoYXBpL3NlcnZpY2VzL3RpbGxlci5wcm90bxIUaGFwaS5zZXJ2aWNlcy50",
            "aWxsZXIaFmhhcGkvY2hhcnQvY2hhcnQucHJvdG8aF2hhcGkvY2hhcnQvY29u",
            "ZmlnLnByb3RvGhpoYXBpL3JlbGVhc2UvcmVsZWFzZS5wcm90bxoXaGFwaS9y",
            "ZWxlYXNlL2luZm8ucHJvdG8aG2hhcGkvcmVsZWFzZS90ZXN0X3J1bi5wcm90",
            "bxoZaGFwaS9yZWxlYXNlL3N0YXR1cy5wcm90bxoaaGFwaS92ZXJzaW9uL3Zl",
            "cnNpb24ucHJvdG8i/gEKE0xpc3RSZWxlYXNlc1JlcXVlc3QSDQoFbGltaXQY",
            "ASABKAMSDgoGb2Zmc2V0GAIgASgJEjYKB3NvcnRfYnkYAyABKA4yJS5oYXBp",
            "LnNlcnZpY2VzLnRpbGxlci5MaXN0U29ydC5Tb3J0QnkSDgoGZmlsdGVyGAQg",
            "ASgJEjwKCnNvcnRfb3JkZXIYBSABKA4yKC5oYXBpLnNlcnZpY2VzLnRpbGxl",
            "ci5MaXN0U29ydC5Tb3J0T3JkZXISLwoMc3RhdHVzX2NvZGVzGAYgAygOMhku",
            "aGFwaS5yZWxlYXNlLlN0YXR1cy5Db2RlEhEKCW5hbWVzcGFjZRgHIAEoCSJe",
            "CghMaXN0U29ydCIyCgZTb3J0QnkSCwoHVU5LTk9XThAAEggKBE5BTUUQARIR",
            "Cg1MQVNUX1JFTEVBU0VEEAIiHgoJU29ydE9yZGVyEgcKA0FTQxAAEggKBERF",
            "U0MQASJrChRMaXN0UmVsZWFzZXNSZXNwb25zZRINCgVjb3VudBgBIAEoAxIM",
            "CgRuZXh0GAIgASgJEg0KBXRvdGFsGAMgASgDEicKCHJlbGVhc2VzGAQgAygL",
            "MhUuaGFwaS5yZWxlYXNlLlJlbGVhc2UiOAoXR2V0UmVsZWFzZVN0YXR1c1Jl",
            "cXVlc3QSDAoEbmFtZRgBIAEoCRIPCgd2ZXJzaW9uGAIgASgFIl0KGEdldFJl",
            "bGVhc2VTdGF0dXNSZXNwb25zZRIMCgRuYW1lGAEgASgJEiAKBGluZm8YAiAB",
            "KAsyEi5oYXBpLnJlbGVhc2UuSW5mbxIRCgluYW1lc3BhY2UYAyABKAkiOQoY",
            "R2V0UmVsZWFzZUNvbnRlbnRSZXF1ZXN0EgwKBG5hbWUYASABKAkSDwoHdmVy",
            "c2lvbhgCIAEoBSJDChlHZXRSZWxlYXNlQ29udGVudFJlc3BvbnNlEiYKB3Jl",
            "bGVhc2UYASABKAsyFS5oYXBpLnJlbGVhc2UuUmVsZWFzZSL+AQoUVXBkYXRl",
            "UmVsZWFzZVJlcXVlc3QSDAoEbmFtZRgBIAEoCRIgCgVjaGFydBgCIAEoCzIR",
            "LmhhcGkuY2hhcnQuQ2hhcnQSIgoGdmFsdWVzGAMgASgLMhIuaGFwaS5jaGFy",
            "dC5Db25maWcSDwoHZHJ5X3J1bhgEIAEoCBIVCg1kaXNhYmxlX2hvb2tzGAUg",
            "ASgIEhAKCHJlY3JlYXRlGAYgASgIEg8KB3RpbWVvdXQYByABKAMSFAoMcmVz",
            "ZXRfdmFsdWVzGAggASgIEgwKBHdhaXQYCSABKAgSFAoMcmV1c2VfdmFsdWVz",
            "GAogASgIEg0KBWZvcmNlGAsgASgIIj8KFVVwZGF0ZVJlbGVhc2VSZXNwb25z",
            "ZRImCgdyZWxlYXNlGAEgASgLMhUuaGFwaS5yZWxlYXNlLlJlbGVhc2UinwEK",
            "FlJvbGxiYWNrUmVsZWFzZVJlcXVlc3QSDAoEbmFtZRgBIAEoCRIPCgdkcnlf",
            "cnVuGAIgASgIEhUKDWRpc2FibGVfaG9va3MYAyABKAgSDwoHdmVyc2lvbhgE",
            "IAEoBRIQCghyZWNyZWF0ZRgFIAEoCBIPCgd0aW1lb3V0GAYgASgDEgwKBHdh",
            "aXQYByABKAgSDQoFZm9yY2UYCCABKAgiQQoXUm9sbGJhY2tSZWxlYXNlUmVz",
            "cG9uc2USJgoHcmVsZWFzZRgBIAEoCzIVLmhhcGkucmVsZWFzZS5SZWxlYXNl",
            "ItkBChVJbnN0YWxsUmVsZWFzZVJlcXVlc3QSIAoFY2hhcnQYASABKAsyES5o",
            "YXBpLmNoYXJ0LkNoYXJ0EiIKBnZhbHVlcxgCIAEoCzISLmhhcGkuY2hhcnQu",
            "Q29uZmlnEg8KB2RyeV9ydW4YAyABKAgSDAoEbmFtZRgEIAEoCRIVCg1kaXNh",
            "YmxlX2hvb2tzGAUgASgIEhEKCW5hbWVzcGFjZRgGIAEoCRISCgpyZXVzZV9u",
            "YW1lGAcgASgIEg8KB3RpbWVvdXQYCCABKAMSDAoEd2FpdBgJIAEoCCJAChZJ",
            "bnN0YWxsUmVsZWFzZVJlc3BvbnNlEiYKB3JlbGVhc2UYASABKAsyFS5oYXBp",
            "LnJlbGVhc2UuUmVsZWFzZSJeChdVbmluc3RhbGxSZWxlYXNlUmVxdWVzdBIM",
            "CgRuYW1lGAEgASgJEhUKDWRpc2FibGVfaG9va3MYAiABKAgSDQoFcHVyZ2UY",
            "AyABKAgSDwoHdGltZW91dBgEIAEoAyJQChhVbmluc3RhbGxSZWxlYXNlUmVz",
            "cG9uc2USJgoHcmVsZWFzZRgBIAEoCzIVLmhhcGkucmVsZWFzZS5SZWxlYXNl",
            "EgwKBGluZm8YAiABKAkiEwoRR2V0VmVyc2lvblJlcXVlc3QiPAoSR2V0VmVy",
            "c2lvblJlc3BvbnNlEiYKB1ZlcnNpb24YASABKAsyFS5oYXBpLnZlcnNpb24u",
            "VmVyc2lvbiIuChFHZXRIaXN0b3J5UmVxdWVzdBIMCgRuYW1lGAEgASgJEgsK",
            "A21heBgCIAEoBSI9ChJHZXRIaXN0b3J5UmVzcG9uc2USJwoIcmVsZWFzZXMY",
            "ASADKAsyFS5oYXBpLnJlbGVhc2UuUmVsZWFzZSJEChJUZXN0UmVsZWFzZVJl",
            "cXVlc3QSDAoEbmFtZRgBIAEoCRIPCgd0aW1lb3V0GAIgASgDEg8KB2NsZWFu",
            "dXAYAyABKAgiUAoTVGVzdFJlbGVhc2VSZXNwb25zZRILCgNtc2cYASABKAkS",
            "LAoGc3RhdHVzGAIgASgOMhwuaGFwaS5yZWxlYXNlLlRlc3RSdW4uU3RhdHVz",
            "MtsICg5SZWxlYXNlU2VydmljZRJpCgxMaXN0UmVsZWFzZXMSKS5oYXBpLnNl",
            "cnZpY2VzLnRpbGxlci5MaXN0UmVsZWFzZXNSZXF1ZXN0GiouaGFwaS5zZXJ2",
            "aWNlcy50aWxsZXIuTGlzdFJlbGVhc2VzUmVzcG9uc2UiADABEnMKEEdldFJl",
            "bGVhc2VTdGF0dXMSLS5oYXBpLnNlcnZpY2VzLnRpbGxlci5HZXRSZWxlYXNl",
            "U3RhdHVzUmVxdWVzdBouLmhhcGkuc2VydmljZXMudGlsbGVyLkdldFJlbGVh",
            "c2VTdGF0dXNSZXNwb25zZSIAEnYKEUdldFJlbGVhc2VDb250ZW50Ei4uaGFw",
            "aS5zZXJ2aWNlcy50aWxsZXIuR2V0UmVsZWFzZUNvbnRlbnRSZXF1ZXN0Gi8u",
            "aGFwaS5zZXJ2aWNlcy50aWxsZXIuR2V0UmVsZWFzZUNvbnRlbnRSZXNwb25z",
            "ZSIAEmoKDVVwZGF0ZVJlbGVhc2USKi5oYXBpLnNlcnZpY2VzLnRpbGxlci5V",
            "cGRhdGVSZWxlYXNlUmVxdWVzdBorLmhhcGkuc2VydmljZXMudGlsbGVyLlVw",
            "ZGF0ZVJlbGVhc2VSZXNwb25zZSIAEm0KDkluc3RhbGxSZWxlYXNlEisuaGFw",
            "aS5zZXJ2aWNlcy50aWxsZXIuSW5zdGFsbFJlbGVhc2VSZXF1ZXN0GiwuaGFw",
            "aS5zZXJ2aWNlcy50aWxsZXIuSW5zdGFsbFJlbGVhc2VSZXNwb25zZSIAEnMK",
            "EFVuaW5zdGFsbFJlbGVhc2USLS5oYXBpLnNlcnZpY2VzLnRpbGxlci5Vbmlu",
            "c3RhbGxSZWxlYXNlUmVxdWVzdBouLmhhcGkuc2VydmljZXMudGlsbGVyLlVu",
            "aW5zdGFsbFJlbGVhc2VSZXNwb25zZSIAEmEKCkdldFZlcnNpb24SJy5oYXBp",
            "LnNlcnZpY2VzLnRpbGxlci5HZXRWZXJzaW9uUmVxdWVzdBooLmhhcGkuc2Vy",
            "dmljZXMudGlsbGVyLkdldFZlcnNpb25SZXNwb25zZSIAEnAKD1JvbGxiYWNr",
            "UmVsZWFzZRIsLmhhcGkuc2VydmljZXMudGlsbGVyLlJvbGxiYWNrUmVsZWFz",
            "ZVJlcXVlc3QaLS5oYXBpLnNlcnZpY2VzLnRpbGxlci5Sb2xsYmFja1JlbGVh",
            "c2VSZXNwb25zZSIAEmEKCkdldEhpc3RvcnkSJy5oYXBpLnNlcnZpY2VzLnRp",
            "bGxlci5HZXRIaXN0b3J5UmVxdWVzdBooLmhhcGkuc2VydmljZXMudGlsbGVy",
            "LkdldEhpc3RvcnlSZXNwb25zZSIAEmkKDlJ1blJlbGVhc2VUZXN0EiguaGFw",
            "aS5zZXJ2aWNlcy50aWxsZXIuVGVzdFJlbGVhc2VSZXF1ZXN0GikuaGFwaS5z",
            "ZXJ2aWNlcy50aWxsZXIuVGVzdFJlbGVhc2VSZXNwb25zZSIAMAFCCloIc2Vy",
            "dmljZXNiBnByb3RvMw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Hapi.Chart.ChartReflection.Descriptor, global::Hapi.Chart.ConfigReflection.Descriptor, global::Hapi.Release.ReleaseReflection.Descriptor, global::Hapi.Release.InfoReflection.Descriptor, global::Hapi.Release.TestRunReflection.Descriptor, global::Hapi.Release.StatusReflection.Descriptor, global::Hapi.Version.VersionReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Hapi.Services.Tiller.ListReleasesRequest), global::Hapi.Services.Tiller.ListReleasesRequest.Parser, new[]{ "Limit", "Offset", "SortBy", "Filter", "SortOrder", "StatusCodes", "Namespace" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Hapi.Services.Tiller.ListSort), global::Hapi.Services.Tiller.ListSort.Parser, null, null, new[]{ typeof(global::Hapi.Services.Tiller.ListSort.Types.SortBy), typeof(global::Hapi.Services.Tiller.ListSort.Types.SortOrder) }, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Hapi.Services.Tiller.ListReleasesResponse), global::Hapi.Services.Tiller.ListReleasesResponse.Parser, new[]{ "Count", "Next", "Total", "Releases" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Hapi.Services.Tiller.GetReleaseStatusRequest), global::Hapi.Services.Tiller.GetReleaseStatusRequest.Parser, new[]{ "Name", "Version" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Hapi.Services.Tiller.GetReleaseStatusResponse), global::Hapi.Services.Tiller.GetReleaseStatusResponse.Parser, new[]{ "Name", "Info", "Namespace" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Hapi.Services.Tiller.GetReleaseContentRequest), global::Hapi.Services.Tiller.GetReleaseContentRequest.Parser, new[]{ "Name", "Version" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Hapi.Services.Tiller.GetReleaseContentResponse), global::Hapi.Services.Tiller.GetReleaseContentResponse.Parser, new[]{ "Release" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Hapi.Services.Tiller.UpdateReleaseRequest), global::Hapi.Services.Tiller.UpdateReleaseRequest.Parser, new[]{ "Name", "Chart", "Values", "DryRun", "DisableHooks", "Recreate", "Timeout", "ResetValues", "Wait", "ReuseValues", "Force" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Hapi.Services.Tiller.UpdateReleaseResponse), global::Hapi.Services.Tiller.UpdateReleaseResponse.Parser, new[]{ "Release" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Hapi.Services.Tiller.RollbackReleaseRequest), global::Hapi.Services.Tiller.RollbackReleaseRequest.Parser, new[]{ "Name", "DryRun", "DisableHooks", "Version", "Recreate", "Timeout", "Wait", "Force" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Hapi.Services.Tiller.RollbackReleaseResponse), global::Hapi.Services.Tiller.RollbackReleaseResponse.Parser, new[]{ "Release" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Hapi.Services.Tiller.InstallReleaseRequest), global::Hapi.Services.Tiller.InstallReleaseRequest.Parser, new[]{ "Chart", "Values", "DryRun", "Name", "DisableHooks", "Namespace", "ReuseName", "Timeout", "Wait" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Hapi.Services.Tiller.InstallReleaseResponse), global::Hapi.Services.Tiller.InstallReleaseResponse.Parser, new[]{ "Release" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Hapi.Services.Tiller.UninstallReleaseRequest), global::Hapi.Services.Tiller.UninstallReleaseRequest.Parser, new[]{ "Name", "DisableHooks", "Purge", "Timeout" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Hapi.Services.Tiller.UninstallReleaseResponse), global::Hapi.Services.Tiller.UninstallReleaseResponse.Parser, new[]{ "Release", "Info" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Hapi.Services.Tiller.GetVersionRequest), global::Hapi.Services.Tiller.GetVersionRequest.Parser, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Hapi.Services.Tiller.GetVersionResponse), global::Hapi.Services.Tiller.GetVersionResponse.Parser, new[]{ "Version" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Hapi.Services.Tiller.GetHistoryRequest), global::Hapi.Services.Tiller.GetHistoryRequest.Parser, new[]{ "Name", "Max" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Hapi.Services.Tiller.GetHistoryResponse), global::Hapi.Services.Tiller.GetHistoryResponse.Parser, new[]{ "Releases" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Hapi.Services.Tiller.TestReleaseRequest), global::Hapi.Services.Tiller.TestReleaseRequest.Parser, new[]{ "Name", "Timeout", "Cleanup" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Hapi.Services.Tiller.TestReleaseResponse), global::Hapi.Services.Tiller.TestReleaseResponse.Parser, new[]{ "Msg", "Status" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// ListReleasesRequest requests a list of releases.
  ///
  /// Releases can be retrieved in chunks by setting limit and offset.
  ///
  /// Releases can be sorted according to a few pre-determined sort stategies.
  /// </summary>
  public sealed partial class ListReleasesRequest : pb::IMessage<ListReleasesRequest> {
    private static readonly pb::MessageParser<ListReleasesRequest> _parser = new pb::MessageParser<ListReleasesRequest>(() => new ListReleasesRequest());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ListReleasesRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Hapi.Services.Tiller.TillerReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ListReleasesRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ListReleasesRequest(ListReleasesRequest other) : this() {
      limit_ = other.limit_;
      offset_ = other.offset_;
      sortBy_ = other.sortBy_;
      filter_ = other.filter_;
      sortOrder_ = other.sortOrder_;
      statusCodes_ = other.statusCodes_.Clone();
      namespace_ = other.namespace_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ListReleasesRequest Clone() {
      return new ListReleasesRequest(this);
    }

    /// <summary>Field number for the "limit" field.</summary>
    public const int LimitFieldNumber = 1;
    private long limit_;
    /// <summary>
    /// Limit is the maximum number of releases to be returned.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long Limit {
      get { return limit_; }
      set {
        limit_ = value;
      }
    }

    /// <summary>Field number for the "offset" field.</summary>
    public const int OffsetFieldNumber = 2;
    private string offset_ = "";
    /// <summary>
    /// Offset is the last release name that was seen. The next listing
    /// operation will start with the name after this one.
    /// Example: If list one returns albert, bernie, carl, and sets 'next: dennis'.
    /// dennis is the offset. Supplying 'dennis' for the next request should
    /// cause the next batch to return a set of results starting with 'dennis'.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Offset {
      get { return offset_; }
      set {
        offset_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "sort_by" field.</summary>
    public const int SortByFieldNumber = 3;
    private global::Hapi.Services.Tiller.ListSort.Types.SortBy sortBy_ = 0;
    /// <summary>
    /// SortBy is the sort field that the ListReleases server should sort data before returning.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Hapi.Services.Tiller.ListSort.Types.SortBy SortBy {
      get { return sortBy_; }
      set {
        sortBy_ = value;
      }
    }

    /// <summary>Field number for the "filter" field.</summary>
    public const int FilterFieldNumber = 4;
    private string filter_ = "";
    /// <summary>
    /// Filter is a regular expression used to filter which releases should be listed.
    ///
    /// Anything that matches the regexp will be included in the results.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Filter {
      get { return filter_; }
      set {
        filter_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "sort_order" field.</summary>
    public const int SortOrderFieldNumber = 5;
    private global::Hapi.Services.Tiller.ListSort.Types.SortOrder sortOrder_ = 0;
    /// <summary>
    /// SortOrder is the ordering directive used for sorting.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Hapi.Services.Tiller.ListSort.Types.SortOrder SortOrder {
      get { return sortOrder_; }
      set {
        sortOrder_ = value;
      }
    }

    /// <summary>Field number for the "status_codes" field.</summary>
    public const int StatusCodesFieldNumber = 6;
    private static readonly pb::FieldCodec<global::Hapi.Release.Status.Types.Code> _repeated_statusCodes_codec
        = pb::FieldCodec.ForEnum(50, x => (int) x, x => (global::Hapi.Release.Status.Types.Code) x);
    private readonly pbc::RepeatedField<global::Hapi.Release.Status.Types.Code> statusCodes_ = new pbc::RepeatedField<global::Hapi.Release.Status.Types.Code>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Hapi.Release.Status.Types.Code> StatusCodes {
      get { return statusCodes_; }
    }

    /// <summary>Field number for the "namespace" field.</summary>
    public const int NamespaceFieldNumber = 7;
    private string namespace_ = "";
    /// <summary>
    /// Namespace is the filter to select releases only from a specific namespace.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Namespace {
      get { return namespace_; }
      set {
        namespace_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ListReleasesRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ListReleasesRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Limit != other.Limit) return false;
      if (Offset != other.Offset) return false;
      if (SortBy != other.SortBy) return false;
      if (Filter != other.Filter) return false;
      if (SortOrder != other.SortOrder) return false;
      if(!statusCodes_.Equals(other.statusCodes_)) return false;
      if (Namespace != other.Namespace) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Limit != 0L) hash ^= Limit.GetHashCode();
      if (Offset.Length != 0) hash ^= Offset.GetHashCode();
      if (SortBy != 0) hash ^= SortBy.GetHashCode();
      if (Filter.Length != 0) hash ^= Filter.GetHashCode();
      if (SortOrder != 0) hash ^= SortOrder.GetHashCode();
      hash ^= statusCodes_.GetHashCode();
      if (Namespace.Length != 0) hash ^= Namespace.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Limit != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(Limit);
      }
      if (Offset.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Offset);
      }
      if (SortBy != 0) {
        output.WriteRawTag(24);
        output.WriteEnum((int) SortBy);
      }
      if (Filter.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(Filter);
      }
      if (SortOrder != 0) {
        output.WriteRawTag(40);
        output.WriteEnum((int) SortOrder);
      }
      statusCodes_.WriteTo(output, _repeated_statusCodes_codec);
      if (Namespace.Length != 0) {
        output.WriteRawTag(58);
        output.WriteString(Namespace);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Limit != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Limit);
      }
      if (Offset.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Offset);
      }
      if (SortBy != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) SortBy);
      }
      if (Filter.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Filter);
      }
      if (SortOrder != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) SortOrder);
      }
      size += statusCodes_.CalculateSize(_repeated_statusCodes_codec);
      if (Namespace.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Namespace);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ListReleasesRequest other) {
      if (other == null) {
        return;
      }
      if (other.Limit != 0L) {
        Limit = other.Limit;
      }
      if (other.Offset.Length != 0) {
        Offset = other.Offset;
      }
      if (other.SortBy != 0) {
        SortBy = other.SortBy;
      }
      if (other.Filter.Length != 0) {
        Filter = other.Filter;
      }
      if (other.SortOrder != 0) {
        SortOrder = other.SortOrder;
      }
      statusCodes_.Add(other.statusCodes_);
      if (other.Namespace.Length != 0) {
        Namespace = other.Namespace;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            Limit = input.ReadInt64();
            break;
          }
          case 18: {
            Offset = input.ReadString();
            break;
          }
          case 24: {
            sortBy_ = (global::Hapi.Services.Tiller.ListSort.Types.SortBy) input.ReadEnum();
            break;
          }
          case 34: {
            Filter = input.ReadString();
            break;
          }
          case 40: {
            sortOrder_ = (global::Hapi.Services.Tiller.ListSort.Types.SortOrder) input.ReadEnum();
            break;
          }
          case 50:
          case 48: {
            statusCodes_.AddEntriesFrom(input, _repeated_statusCodes_codec);
            break;
          }
          case 58: {
            Namespace = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// ListSort defines sorting fields on a release list.
  /// </summary>
  public sealed partial class ListSort : pb::IMessage<ListSort> {
    private static readonly pb::MessageParser<ListSort> _parser = new pb::MessageParser<ListSort>(() => new ListSort());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ListSort> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Hapi.Services.Tiller.TillerReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ListSort() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ListSort(ListSort other) : this() {
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ListSort Clone() {
      return new ListSort(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ListSort);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ListSort other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ListSort other) {
      if (other == null) {
        return;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the ListSort message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// SortBy defines sort operations.
      /// </summary>
      public enum SortBy {
        [pbr::OriginalName("UNKNOWN")] Unknown = 0,
        [pbr::OriginalName("NAME")] Name = 1,
        [pbr::OriginalName("LAST_RELEASED")] LastReleased = 2,
      }

      /// <summary>
      /// SortOrder defines sort orders to augment sorting operations.
      /// </summary>
      public enum SortOrder {
        [pbr::OriginalName("ASC")] Asc = 0,
        [pbr::OriginalName("DESC")] Desc = 1,
      }

    }
    #endregion

  }

  /// <summary>
  /// ListReleasesResponse is a list of releases.
  /// </summary>
  public sealed partial class ListReleasesResponse : pb::IMessage<ListReleasesResponse> {
    private static readonly pb::MessageParser<ListReleasesResponse> _parser = new pb::MessageParser<ListReleasesResponse>(() => new ListReleasesResponse());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ListReleasesResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Hapi.Services.Tiller.TillerReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ListReleasesResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ListReleasesResponse(ListReleasesResponse other) : this() {
      count_ = other.count_;
      next_ = other.next_;
      total_ = other.total_;
      releases_ = other.releases_.Clone();
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ListReleasesResponse Clone() {
      return new ListReleasesResponse(this);
    }

    /// <summary>Field number for the "count" field.</summary>
    public const int CountFieldNumber = 1;
    private long count_;
    /// <summary>
    /// Count is the expected total number of releases to be returned.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long Count {
      get { return count_; }
      set {
        count_ = value;
      }
    }

    /// <summary>Field number for the "next" field.</summary>
    public const int NextFieldNumber = 2;
    private string next_ = "";
    /// <summary>
    /// Next is the name of the next release. If this is other than an empty
    /// string, it means there are more results.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Next {
      get { return next_; }
      set {
        next_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "total" field.</summary>
    public const int TotalFieldNumber = 3;
    private long total_;
    /// <summary>
    /// Total is the total number of queryable releases.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long Total {
      get { return total_; }
      set {
        total_ = value;
      }
    }

    /// <summary>Field number for the "releases" field.</summary>
    public const int ReleasesFieldNumber = 4;
    private static readonly pb::FieldCodec<global::Hapi.Release.Release> _repeated_releases_codec
        = pb::FieldCodec.ForMessage(34, global::Hapi.Release.Release.Parser);
    private readonly pbc::RepeatedField<global::Hapi.Release.Release> releases_ = new pbc::RepeatedField<global::Hapi.Release.Release>();
    /// <summary>
    /// Releases is the list of found release objects.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Hapi.Release.Release> Releases {
      get { return releases_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ListReleasesResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ListReleasesResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Count != other.Count) return false;
      if (Next != other.Next) return false;
      if (Total != other.Total) return false;
      if(!releases_.Equals(other.releases_)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Count != 0L) hash ^= Count.GetHashCode();
      if (Next.Length != 0) hash ^= Next.GetHashCode();
      if (Total != 0L) hash ^= Total.GetHashCode();
      hash ^= releases_.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Count != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(Count);
      }
      if (Next.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Next);
      }
      if (Total != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(Total);
      }
      releases_.WriteTo(output, _repeated_releases_codec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Count != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Count);
      }
      if (Next.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Next);
      }
      if (Total != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Total);
      }
      size += releases_.CalculateSize(_repeated_releases_codec);
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ListReleasesResponse other) {
      if (other == null) {
        return;
      }
      if (other.Count != 0L) {
        Count = other.Count;
      }
      if (other.Next.Length != 0) {
        Next = other.Next;
      }
      if (other.Total != 0L) {
        Total = other.Total;
      }
      releases_.Add(other.releases_);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            Count = input.ReadInt64();
            break;
          }
          case 18: {
            Next = input.ReadString();
            break;
          }
          case 24: {
            Total = input.ReadInt64();
            break;
          }
          case 34: {
            releases_.AddEntriesFrom(input, _repeated_releases_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// GetReleaseStatusRequest is a request to get the status of a release.
  /// </summary>
  public sealed partial class GetReleaseStatusRequest : pb::IMessage<GetReleaseStatusRequest> {
    private static readonly pb::MessageParser<GetReleaseStatusRequest> _parser = new pb::MessageParser<GetReleaseStatusRequest>(() => new GetReleaseStatusRequest());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<GetReleaseStatusRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Hapi.Services.Tiller.TillerReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetReleaseStatusRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetReleaseStatusRequest(GetReleaseStatusRequest other) : this() {
      name_ = other.name_;
      version_ = other.version_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetReleaseStatusRequest Clone() {
      return new GetReleaseStatusRequest(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// Name is the name of the release
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "version" field.</summary>
    public const int VersionFieldNumber = 2;
    private int version_;
    /// <summary>
    /// Version is the version of the release
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Version {
      get { return version_; }
      set {
        version_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as GetReleaseStatusRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(GetReleaseStatusRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (Version != other.Version) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (Version != 0) hash ^= Version.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (Version != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(Version);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (Version != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Version);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(GetReleaseStatusRequest other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.Version != 0) {
        Version = other.Version;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            Version = input.ReadInt32();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// GetReleaseStatusResponse is the response indicating the status of the named release.
  /// </summary>
  public sealed partial class GetReleaseStatusResponse : pb::IMessage<GetReleaseStatusResponse> {
    private static readonly pb::MessageParser<GetReleaseStatusResponse> _parser = new pb::MessageParser<GetReleaseStatusResponse>(() => new GetReleaseStatusResponse());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<GetReleaseStatusResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Hapi.Services.Tiller.TillerReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetReleaseStatusResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetReleaseStatusResponse(GetReleaseStatusResponse other) : this() {
      name_ = other.name_;
      Info = other.info_ != null ? other.Info.Clone() : null;
      namespace_ = other.namespace_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetReleaseStatusResponse Clone() {
      return new GetReleaseStatusResponse(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// Name is the name of the release.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "info" field.</summary>
    public const int InfoFieldNumber = 2;
    private global::Hapi.Release.Info info_;
    /// <summary>
    /// Info contains information about the release.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Hapi.Release.Info Info {
      get { return info_; }
      set {
        info_ = value;
      }
    }

    /// <summary>Field number for the "namespace" field.</summary>
    public const int NamespaceFieldNumber = 3;
    private string namespace_ = "";
    /// <summary>
    /// Namesapce the release was released into
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Namespace {
      get { return namespace_; }
      set {
        namespace_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as GetReleaseStatusResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(GetReleaseStatusResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (!object.Equals(Info, other.Info)) return false;
      if (Namespace != other.Namespace) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (info_ != null) hash ^= Info.GetHashCode();
      if (Namespace.Length != 0) hash ^= Namespace.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (info_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Info);
      }
      if (Namespace.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Namespace);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (info_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Info);
      }
      if (Namespace.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Namespace);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(GetReleaseStatusResponse other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.info_ != null) {
        if (info_ == null) {
          info_ = new global::Hapi.Release.Info();
        }
        Info.MergeFrom(other.Info);
      }
      if (other.Namespace.Length != 0) {
        Namespace = other.Namespace;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            if (info_ == null) {
              info_ = new global::Hapi.Release.Info();
            }
            input.ReadMessage(info_);
            break;
          }
          case 26: {
            Namespace = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// GetReleaseContentRequest is a request to get the contents of a release.
  /// </summary>
  public sealed partial class GetReleaseContentRequest : pb::IMessage<GetReleaseContentRequest> {
    private static readonly pb::MessageParser<GetReleaseContentRequest> _parser = new pb::MessageParser<GetReleaseContentRequest>(() => new GetReleaseContentRequest());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<GetReleaseContentRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Hapi.Services.Tiller.TillerReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetReleaseContentRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetReleaseContentRequest(GetReleaseContentRequest other) : this() {
      name_ = other.name_;
      version_ = other.version_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetReleaseContentRequest Clone() {
      return new GetReleaseContentRequest(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// The name of the release
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "version" field.</summary>
    public const int VersionFieldNumber = 2;
    private int version_;
    /// <summary>
    /// Version is the version of the release
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Version {
      get { return version_; }
      set {
        version_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as GetReleaseContentRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(GetReleaseContentRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (Version != other.Version) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (Version != 0) hash ^= Version.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (Version != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(Version);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (Version != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Version);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(GetReleaseContentRequest other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.Version != 0) {
        Version = other.Version;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            Version = input.ReadInt32();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// GetReleaseContentResponse is a response containing the contents of a release.
  /// </summary>
  public sealed partial class GetReleaseContentResponse : pb::IMessage<GetReleaseContentResponse> {
    private static readonly pb::MessageParser<GetReleaseContentResponse> _parser = new pb::MessageParser<GetReleaseContentResponse>(() => new GetReleaseContentResponse());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<GetReleaseContentResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Hapi.Services.Tiller.TillerReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetReleaseContentResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetReleaseContentResponse(GetReleaseContentResponse other) : this() {
      Release = other.release_ != null ? other.Release.Clone() : null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetReleaseContentResponse Clone() {
      return new GetReleaseContentResponse(this);
    }

    /// <summary>Field number for the "release" field.</summary>
    public const int ReleaseFieldNumber = 1;
    private global::Hapi.Release.Release release_;
    /// <summary>
    /// The release content
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Hapi.Release.Release Release {
      get { return release_; }
      set {
        release_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as GetReleaseContentResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(GetReleaseContentResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Release, other.Release)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (release_ != null) hash ^= Release.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (release_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Release);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (release_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Release);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(GetReleaseContentResponse other) {
      if (other == null) {
        return;
      }
      if (other.release_ != null) {
        if (release_ == null) {
          release_ = new global::Hapi.Release.Release();
        }
        Release.MergeFrom(other.Release);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            if (release_ == null) {
              release_ = new global::Hapi.Release.Release();
            }
            input.ReadMessage(release_);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// UpdateReleaseRequest updates a release.
  /// </summary>
  public sealed partial class UpdateReleaseRequest : pb::IMessage<UpdateReleaseRequest> {
    private static readonly pb::MessageParser<UpdateReleaseRequest> _parser = new pb::MessageParser<UpdateReleaseRequest>(() => new UpdateReleaseRequest());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<UpdateReleaseRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Hapi.Services.Tiller.TillerReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UpdateReleaseRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UpdateReleaseRequest(UpdateReleaseRequest other) : this() {
      name_ = other.name_;
      Chart = other.chart_ != null ? other.Chart.Clone() : null;
      Values = other.values_ != null ? other.Values.Clone() : null;
      dryRun_ = other.dryRun_;
      disableHooks_ = other.disableHooks_;
      recreate_ = other.recreate_;
      timeout_ = other.timeout_;
      resetValues_ = other.resetValues_;
      wait_ = other.wait_;
      reuseValues_ = other.reuseValues_;
      force_ = other.force_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UpdateReleaseRequest Clone() {
      return new UpdateReleaseRequest(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// The name of the release
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "chart" field.</summary>
    public const int ChartFieldNumber = 2;
    private global::Hapi.Chart.Chart chart_;
    /// <summary>
    /// Chart is the protobuf representation of a chart.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Hapi.Chart.Chart Chart {
      get { return chart_; }
      set {
        chart_ = value;
      }
    }

    /// <summary>Field number for the "values" field.</summary>
    public const int ValuesFieldNumber = 3;
    private global::Hapi.Chart.Config values_;
    /// <summary>
    /// Values is a string containing (unparsed) YAML values.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Hapi.Chart.Config Values {
      get { return values_; }
      set {
        values_ = value;
      }
    }

    /// <summary>Field number for the "dry_run" field.</summary>
    public const int DryRunFieldNumber = 4;
    private bool dryRun_;
    /// <summary>
    /// dry_run, if true, will run through the release logic, but neither create
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool DryRun {
      get { return dryRun_; }
      set {
        dryRun_ = value;
      }
    }

    /// <summary>Field number for the "disable_hooks" field.</summary>
    public const int DisableHooksFieldNumber = 5;
    private bool disableHooks_;
    /// <summary>
    /// DisableHooks causes the server to skip running any hooks for the upgrade.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool DisableHooks {
      get { return disableHooks_; }
      set {
        disableHooks_ = value;
      }
    }

    /// <summary>Field number for the "recreate" field.</summary>
    public const int RecreateFieldNumber = 6;
    private bool recreate_;
    /// <summary>
    /// Performs pods restart for resources if applicable
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Recreate {
      get { return recreate_; }
      set {
        recreate_ = value;
      }
    }

    /// <summary>Field number for the "timeout" field.</summary>
    public const int TimeoutFieldNumber = 7;
    private long timeout_;
    /// <summary>
    /// timeout specifies the max amount of time any kubernetes client command can run.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long Timeout {
      get { return timeout_; }
      set {
        timeout_ = value;
      }
    }

    /// <summary>Field number for the "reset_values" field.</summary>
    public const int ResetValuesFieldNumber = 8;
    private bool resetValues_;
    /// <summary>
    /// ResetValues will cause Tiller to ignore stored values, resetting to default values.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool ResetValues {
      get { return resetValues_; }
      set {
        resetValues_ = value;
      }
    }

    /// <summary>Field number for the "wait" field.</summary>
    public const int WaitFieldNumber = 9;
    private bool wait_;
    /// <summary>
    /// wait, if true, will wait until all Pods, PVCs, and Services are in a ready state
    /// before marking the release as successful. It will wait for as long as timeout
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Wait {
      get { return wait_; }
      set {
        wait_ = value;
      }
    }

    /// <summary>Field number for the "reuse_values" field.</summary>
    public const int ReuseValuesFieldNumber = 10;
    private bool reuseValues_;
    /// <summary>
    /// ReuseValues will cause Tiller to reuse the values from the last release.
    /// This is ignored if reset_values is set.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool ReuseValues {
      get { return reuseValues_; }
      set {
        reuseValues_ = value;
      }
    }

    /// <summary>Field number for the "force" field.</summary>
    public const int ForceFieldNumber = 11;
    private bool force_;
    /// <summary>
    /// Force resource update through delete/recreate if needed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Force {
      get { return force_; }
      set {
        force_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as UpdateReleaseRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(UpdateReleaseRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (!object.Equals(Chart, other.Chart)) return false;
      if (!object.Equals(Values, other.Values)) return false;
      if (DryRun != other.DryRun) return false;
      if (DisableHooks != other.DisableHooks) return false;
      if (Recreate != other.Recreate) return false;
      if (Timeout != other.Timeout) return false;
      if (ResetValues != other.ResetValues) return false;
      if (Wait != other.Wait) return false;
      if (ReuseValues != other.ReuseValues) return false;
      if (Force != other.Force) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (chart_ != null) hash ^= Chart.GetHashCode();
      if (values_ != null) hash ^= Values.GetHashCode();
      if (DryRun != false) hash ^= DryRun.GetHashCode();
      if (DisableHooks != false) hash ^= DisableHooks.GetHashCode();
      if (Recreate != false) hash ^= Recreate.GetHashCode();
      if (Timeout != 0L) hash ^= Timeout.GetHashCode();
      if (ResetValues != false) hash ^= ResetValues.GetHashCode();
      if (Wait != false) hash ^= Wait.GetHashCode();
      if (ReuseValues != false) hash ^= ReuseValues.GetHashCode();
      if (Force != false) hash ^= Force.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (chart_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Chart);
      }
      if (values_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Values);
      }
      if (DryRun != false) {
        output.WriteRawTag(32);
        output.WriteBool(DryRun);
      }
      if (DisableHooks != false) {
        output.WriteRawTag(40);
        output.WriteBool(DisableHooks);
      }
      if (Recreate != false) {
        output.WriteRawTag(48);
        output.WriteBool(Recreate);
      }
      if (Timeout != 0L) {
        output.WriteRawTag(56);
        output.WriteInt64(Timeout);
      }
      if (ResetValues != false) {
        output.WriteRawTag(64);
        output.WriteBool(ResetValues);
      }
      if (Wait != false) {
        output.WriteRawTag(72);
        output.WriteBool(Wait);
      }
      if (ReuseValues != false) {
        output.WriteRawTag(80);
        output.WriteBool(ReuseValues);
      }
      if (Force != false) {
        output.WriteRawTag(88);
        output.WriteBool(Force);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (chart_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Chart);
      }
      if (values_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Values);
      }
      if (DryRun != false) {
        size += 1 + 1;
      }
      if (DisableHooks != false) {
        size += 1 + 1;
      }
      if (Recreate != false) {
        size += 1 + 1;
      }
      if (Timeout != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Timeout);
      }
      if (ResetValues != false) {
        size += 1 + 1;
      }
      if (Wait != false) {
        size += 1 + 1;
      }
      if (ReuseValues != false) {
        size += 1 + 1;
      }
      if (Force != false) {
        size += 1 + 1;
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(UpdateReleaseRequest other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.chart_ != null) {
        if (chart_ == null) {
          chart_ = new global::Hapi.Chart.Chart();
        }
        Chart.MergeFrom(other.Chart);
      }
      if (other.values_ != null) {
        if (values_ == null) {
          values_ = new global::Hapi.Chart.Config();
        }
        Values.MergeFrom(other.Values);
      }
      if (other.DryRun != false) {
        DryRun = other.DryRun;
      }
      if (other.DisableHooks != false) {
        DisableHooks = other.DisableHooks;
      }
      if (other.Recreate != false) {
        Recreate = other.Recreate;
      }
      if (other.Timeout != 0L) {
        Timeout = other.Timeout;
      }
      if (other.ResetValues != false) {
        ResetValues = other.ResetValues;
      }
      if (other.Wait != false) {
        Wait = other.Wait;
      }
      if (other.ReuseValues != false) {
        ReuseValues = other.ReuseValues;
      }
      if (other.Force != false) {
        Force = other.Force;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            if (chart_ == null) {
              chart_ = new global::Hapi.Chart.Chart();
            }
            input.ReadMessage(chart_);
            break;
          }
          case 26: {
            if (values_ == null) {
              values_ = new global::Hapi.Chart.Config();
            }
            input.ReadMessage(values_);
            break;
          }
          case 32: {
            DryRun = input.ReadBool();
            break;
          }
          case 40: {
            DisableHooks = input.ReadBool();
            break;
          }
          case 48: {
            Recreate = input.ReadBool();
            break;
          }
          case 56: {
            Timeout = input.ReadInt64();
            break;
          }
          case 64: {
            ResetValues = input.ReadBool();
            break;
          }
          case 72: {
            Wait = input.ReadBool();
            break;
          }
          case 80: {
            ReuseValues = input.ReadBool();
            break;
          }
          case 88: {
            Force = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// UpdateReleaseResponse is the response to an update request.
  /// </summary>
  public sealed partial class UpdateReleaseResponse : pb::IMessage<UpdateReleaseResponse> {
    private static readonly pb::MessageParser<UpdateReleaseResponse> _parser = new pb::MessageParser<UpdateReleaseResponse>(() => new UpdateReleaseResponse());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<UpdateReleaseResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Hapi.Services.Tiller.TillerReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UpdateReleaseResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UpdateReleaseResponse(UpdateReleaseResponse other) : this() {
      Release = other.release_ != null ? other.Release.Clone() : null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UpdateReleaseResponse Clone() {
      return new UpdateReleaseResponse(this);
    }

    /// <summary>Field number for the "release" field.</summary>
    public const int ReleaseFieldNumber = 1;
    private global::Hapi.Release.Release release_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Hapi.Release.Release Release {
      get { return release_; }
      set {
        release_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as UpdateReleaseResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(UpdateReleaseResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Release, other.Release)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (release_ != null) hash ^= Release.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (release_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Release);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (release_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Release);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(UpdateReleaseResponse other) {
      if (other == null) {
        return;
      }
      if (other.release_ != null) {
        if (release_ == null) {
          release_ = new global::Hapi.Release.Release();
        }
        Release.MergeFrom(other.Release);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            if (release_ == null) {
              release_ = new global::Hapi.Release.Release();
            }
            input.ReadMessage(release_);
            break;
          }
        }
      }
    }

  }

  public sealed partial class RollbackReleaseRequest : pb::IMessage<RollbackReleaseRequest> {
    private static readonly pb::MessageParser<RollbackReleaseRequest> _parser = new pb::MessageParser<RollbackReleaseRequest>(() => new RollbackReleaseRequest());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RollbackReleaseRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Hapi.Services.Tiller.TillerReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RollbackReleaseRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RollbackReleaseRequest(RollbackReleaseRequest other) : this() {
      name_ = other.name_;
      dryRun_ = other.dryRun_;
      disableHooks_ = other.disableHooks_;
      version_ = other.version_;
      recreate_ = other.recreate_;
      timeout_ = other.timeout_;
      wait_ = other.wait_;
      force_ = other.force_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RollbackReleaseRequest Clone() {
      return new RollbackReleaseRequest(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// The name of the release
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "dry_run" field.</summary>
    public const int DryRunFieldNumber = 2;
    private bool dryRun_;
    /// <summary>
    /// dry_run, if true, will run through the release logic but no create
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool DryRun {
      get { return dryRun_; }
      set {
        dryRun_ = value;
      }
    }

    /// <summary>Field number for the "disable_hooks" field.</summary>
    public const int DisableHooksFieldNumber = 3;
    private bool disableHooks_;
    /// <summary>
    /// DisableHooks causes the server to skip running any hooks for the rollback
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool DisableHooks {
      get { return disableHooks_; }
      set {
        disableHooks_ = value;
      }
    }

    /// <summary>Field number for the "version" field.</summary>
    public const int VersionFieldNumber = 4;
    private int version_;
    /// <summary>
    /// Version is the version of the release to deploy.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Version {
      get { return version_; }
      set {
        version_ = value;
      }
    }

    /// <summary>Field number for the "recreate" field.</summary>
    public const int RecreateFieldNumber = 5;
    private bool recreate_;
    /// <summary>
    /// Performs pods restart for resources if applicable
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Recreate {
      get { return recreate_; }
      set {
        recreate_ = value;
      }
    }

    /// <summary>Field number for the "timeout" field.</summary>
    public const int TimeoutFieldNumber = 6;
    private long timeout_;
    /// <summary>
    /// timeout specifies the max amount of time any kubernetes client command can run.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long Timeout {
      get { return timeout_; }
      set {
        timeout_ = value;
      }
    }

    /// <summary>Field number for the "wait" field.</summary>
    public const int WaitFieldNumber = 7;
    private bool wait_;
    /// <summary>
    /// wait, if true, will wait until all Pods, PVCs, and Services are in a ready state
    /// before marking the release as successful. It will wait for as long as timeout
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Wait {
      get { return wait_; }
      set {
        wait_ = value;
      }
    }

    /// <summary>Field number for the "force" field.</summary>
    public const int ForceFieldNumber = 8;
    private bool force_;
    /// <summary>
    /// Force resource update through delete/recreate if needed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Force {
      get { return force_; }
      set {
        force_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RollbackReleaseRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RollbackReleaseRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (DryRun != other.DryRun) return false;
      if (DisableHooks != other.DisableHooks) return false;
      if (Version != other.Version) return false;
      if (Recreate != other.Recreate) return false;
      if (Timeout != other.Timeout) return false;
      if (Wait != other.Wait) return false;
      if (Force != other.Force) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (DryRun != false) hash ^= DryRun.GetHashCode();
      if (DisableHooks != false) hash ^= DisableHooks.GetHashCode();
      if (Version != 0) hash ^= Version.GetHashCode();
      if (Recreate != false) hash ^= Recreate.GetHashCode();
      if (Timeout != 0L) hash ^= Timeout.GetHashCode();
      if (Wait != false) hash ^= Wait.GetHashCode();
      if (Force != false) hash ^= Force.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (DryRun != false) {
        output.WriteRawTag(16);
        output.WriteBool(DryRun);
      }
      if (DisableHooks != false) {
        output.WriteRawTag(24);
        output.WriteBool(DisableHooks);
      }
      if (Version != 0) {
        output.WriteRawTag(32);
        output.WriteInt32(Version);
      }
      if (Recreate != false) {
        output.WriteRawTag(40);
        output.WriteBool(Recreate);
      }
      if (Timeout != 0L) {
        output.WriteRawTag(48);
        output.WriteInt64(Timeout);
      }
      if (Wait != false) {
        output.WriteRawTag(56);
        output.WriteBool(Wait);
      }
      if (Force != false) {
        output.WriteRawTag(64);
        output.WriteBool(Force);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (DryRun != false) {
        size += 1 + 1;
      }
      if (DisableHooks != false) {
        size += 1 + 1;
      }
      if (Version != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Version);
      }
      if (Recreate != false) {
        size += 1 + 1;
      }
      if (Timeout != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Timeout);
      }
      if (Wait != false) {
        size += 1 + 1;
      }
      if (Force != false) {
        size += 1 + 1;
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RollbackReleaseRequest other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.DryRun != false) {
        DryRun = other.DryRun;
      }
      if (other.DisableHooks != false) {
        DisableHooks = other.DisableHooks;
      }
      if (other.Version != 0) {
        Version = other.Version;
      }
      if (other.Recreate != false) {
        Recreate = other.Recreate;
      }
      if (other.Timeout != 0L) {
        Timeout = other.Timeout;
      }
      if (other.Wait != false) {
        Wait = other.Wait;
      }
      if (other.Force != false) {
        Force = other.Force;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            DryRun = input.ReadBool();
            break;
          }
          case 24: {
            DisableHooks = input.ReadBool();
            break;
          }
          case 32: {
            Version = input.ReadInt32();
            break;
          }
          case 40: {
            Recreate = input.ReadBool();
            break;
          }
          case 48: {
            Timeout = input.ReadInt64();
            break;
          }
          case 56: {
            Wait = input.ReadBool();
            break;
          }
          case 64: {
            Force = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// RollbackReleaseResponse is the response to an update request.
  /// </summary>
  public sealed partial class RollbackReleaseResponse : pb::IMessage<RollbackReleaseResponse> {
    private static readonly pb::MessageParser<RollbackReleaseResponse> _parser = new pb::MessageParser<RollbackReleaseResponse>(() => new RollbackReleaseResponse());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RollbackReleaseResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Hapi.Services.Tiller.TillerReflection.Descriptor.MessageTypes[10]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RollbackReleaseResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RollbackReleaseResponse(RollbackReleaseResponse other) : this() {
      Release = other.release_ != null ? other.Release.Clone() : null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RollbackReleaseResponse Clone() {
      return new RollbackReleaseResponse(this);
    }

    /// <summary>Field number for the "release" field.</summary>
    public const int ReleaseFieldNumber = 1;
    private global::Hapi.Release.Release release_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Hapi.Release.Release Release {
      get { return release_; }
      set {
        release_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RollbackReleaseResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RollbackReleaseResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Release, other.Release)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (release_ != null) hash ^= Release.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (release_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Release);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (release_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Release);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RollbackReleaseResponse other) {
      if (other == null) {
        return;
      }
      if (other.release_ != null) {
        if (release_ == null) {
          release_ = new global::Hapi.Release.Release();
        }
        Release.MergeFrom(other.Release);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            if (release_ == null) {
              release_ = new global::Hapi.Release.Release();
            }
            input.ReadMessage(release_);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// InstallReleaseRequest is the request for an installation of a chart.
  /// </summary>
  public sealed partial class InstallReleaseRequest : pb::IMessage<InstallReleaseRequest> {
    private static readonly pb::MessageParser<InstallReleaseRequest> _parser = new pb::MessageParser<InstallReleaseRequest>(() => new InstallReleaseRequest());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<InstallReleaseRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Hapi.Services.Tiller.TillerReflection.Descriptor.MessageTypes[11]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public InstallReleaseRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public InstallReleaseRequest(InstallReleaseRequest other) : this() {
      Chart = other.chart_ != null ? other.Chart.Clone() : null;
      Values = other.values_ != null ? other.Values.Clone() : null;
      dryRun_ = other.dryRun_;
      name_ = other.name_;
      disableHooks_ = other.disableHooks_;
      namespace_ = other.namespace_;
      reuseName_ = other.reuseName_;
      timeout_ = other.timeout_;
      wait_ = other.wait_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public InstallReleaseRequest Clone() {
      return new InstallReleaseRequest(this);
    }

    /// <summary>Field number for the "chart" field.</summary>
    public const int ChartFieldNumber = 1;
    private global::Hapi.Chart.Chart chart_;
    /// <summary>
    /// Chart is the protobuf representation of a chart.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Hapi.Chart.Chart Chart {
      get { return chart_; }
      set {
        chart_ = value;
      }
    }

    /// <summary>Field number for the "values" field.</summary>
    public const int ValuesFieldNumber = 2;
    private global::Hapi.Chart.Config values_;
    /// <summary>
    /// Values is a string containing (unparsed) YAML values.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Hapi.Chart.Config Values {
      get { return values_; }
      set {
        values_ = value;
      }
    }

    /// <summary>Field number for the "dry_run" field.</summary>
    public const int DryRunFieldNumber = 3;
    private bool dryRun_;
    /// <summary>
    /// DryRun, if true, will run through the release logic, but neither create
    /// a release object nor deploy to Kubernetes. The release object returned
    /// in the response will be fake.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool DryRun {
      get { return dryRun_; }
      set {
        dryRun_ = value;
      }
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 4;
    private string name_ = "";
    /// <summary>
    /// Name is the candidate release name. This must be unique to the
    /// namespace, otherwise the server will return an error. If it is not
    /// supplied, the server will autogenerate one.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "disable_hooks" field.</summary>
    public const int DisableHooksFieldNumber = 5;
    private bool disableHooks_;
    /// <summary>
    /// DisableHooks causes the server to skip running any hooks for the install.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool DisableHooks {
      get { return disableHooks_; }
      set {
        disableHooks_ = value;
      }
    }

    /// <summary>Field number for the "namespace" field.</summary>
    public const int NamespaceFieldNumber = 6;
    private string namespace_ = "";
    /// <summary>
    /// Namepace is the kubernetes namespace of the release.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Namespace {
      get { return namespace_; }
      set {
        namespace_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "reuse_name" field.</summary>
    public const int ReuseNameFieldNumber = 7;
    private bool reuseName_;
    /// <summary>
    /// ReuseName requests that Tiller re-uses a name, instead of erroring out.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool ReuseName {
      get { return reuseName_; }
      set {
        reuseName_ = value;
      }
    }

    /// <summary>Field number for the "timeout" field.</summary>
    public const int TimeoutFieldNumber = 8;
    private long timeout_;
    /// <summary>
    /// timeout specifies the max amount of time any kubernetes client command can run.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long Timeout {
      get { return timeout_; }
      set {
        timeout_ = value;
      }
    }

    /// <summary>Field number for the "wait" field.</summary>
    public const int WaitFieldNumber = 9;
    private bool wait_;
    /// <summary>
    /// wait, if true, will wait until all Pods, PVCs, and Services are in a ready state
    /// before marking the release as successful. It will wait for as long as timeout
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Wait {
      get { return wait_; }
      set {
        wait_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as InstallReleaseRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(InstallReleaseRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Chart, other.Chart)) return false;
      if (!object.Equals(Values, other.Values)) return false;
      if (DryRun != other.DryRun) return false;
      if (Name != other.Name) return false;
      if (DisableHooks != other.DisableHooks) return false;
      if (Namespace != other.Namespace) return false;
      if (ReuseName != other.ReuseName) return false;
      if (Timeout != other.Timeout) return false;
      if (Wait != other.Wait) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (chart_ != null) hash ^= Chart.GetHashCode();
      if (values_ != null) hash ^= Values.GetHashCode();
      if (DryRun != false) hash ^= DryRun.GetHashCode();
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (DisableHooks != false) hash ^= DisableHooks.GetHashCode();
      if (Namespace.Length != 0) hash ^= Namespace.GetHashCode();
      if (ReuseName != false) hash ^= ReuseName.GetHashCode();
      if (Timeout != 0L) hash ^= Timeout.GetHashCode();
      if (Wait != false) hash ^= Wait.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (chart_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Chart);
      }
      if (values_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Values);
      }
      if (DryRun != false) {
        output.WriteRawTag(24);
        output.WriteBool(DryRun);
      }
      if (Name.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(Name);
      }
      if (DisableHooks != false) {
        output.WriteRawTag(40);
        output.WriteBool(DisableHooks);
      }
      if (Namespace.Length != 0) {
        output.WriteRawTag(50);
        output.WriteString(Namespace);
      }
      if (ReuseName != false) {
        output.WriteRawTag(56);
        output.WriteBool(ReuseName);
      }
      if (Timeout != 0L) {
        output.WriteRawTag(64);
        output.WriteInt64(Timeout);
      }
      if (Wait != false) {
        output.WriteRawTag(72);
        output.WriteBool(Wait);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (chart_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Chart);
      }
      if (values_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Values);
      }
      if (DryRun != false) {
        size += 1 + 1;
      }
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (DisableHooks != false) {
        size += 1 + 1;
      }
      if (Namespace.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Namespace);
      }
      if (ReuseName != false) {
        size += 1 + 1;
      }
      if (Timeout != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Timeout);
      }
      if (Wait != false) {
        size += 1 + 1;
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(InstallReleaseRequest other) {
      if (other == null) {
        return;
      }
      if (other.chart_ != null) {
        if (chart_ == null) {
          chart_ = new global::Hapi.Chart.Chart();
        }
        Chart.MergeFrom(other.Chart);
      }
      if (other.values_ != null) {
        if (values_ == null) {
          values_ = new global::Hapi.Chart.Config();
        }
        Values.MergeFrom(other.Values);
      }
      if (other.DryRun != false) {
        DryRun = other.DryRun;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.DisableHooks != false) {
        DisableHooks = other.DisableHooks;
      }
      if (other.Namespace.Length != 0) {
        Namespace = other.Namespace;
      }
      if (other.ReuseName != false) {
        ReuseName = other.ReuseName;
      }
      if (other.Timeout != 0L) {
        Timeout = other.Timeout;
      }
      if (other.Wait != false) {
        Wait = other.Wait;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            if (chart_ == null) {
              chart_ = new global::Hapi.Chart.Chart();
            }
            input.ReadMessage(chart_);
            break;
          }
          case 18: {
            if (values_ == null) {
              values_ = new global::Hapi.Chart.Config();
            }
            input.ReadMessage(values_);
            break;
          }
          case 24: {
            DryRun = input.ReadBool();
            break;
          }
          case 34: {
            Name = input.ReadString();
            break;
          }
          case 40: {
            DisableHooks = input.ReadBool();
            break;
          }
          case 50: {
            Namespace = input.ReadString();
            break;
          }
          case 56: {
            ReuseName = input.ReadBool();
            break;
          }
          case 64: {
            Timeout = input.ReadInt64();
            break;
          }
          case 72: {
            Wait = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// InstallReleaseResponse is the response from a release installation.
  /// </summary>
  public sealed partial class InstallReleaseResponse : pb::IMessage<InstallReleaseResponse> {
    private static readonly pb::MessageParser<InstallReleaseResponse> _parser = new pb::MessageParser<InstallReleaseResponse>(() => new InstallReleaseResponse());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<InstallReleaseResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Hapi.Services.Tiller.TillerReflection.Descriptor.MessageTypes[12]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public InstallReleaseResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public InstallReleaseResponse(InstallReleaseResponse other) : this() {
      Release = other.release_ != null ? other.Release.Clone() : null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public InstallReleaseResponse Clone() {
      return new InstallReleaseResponse(this);
    }

    /// <summary>Field number for the "release" field.</summary>
    public const int ReleaseFieldNumber = 1;
    private global::Hapi.Release.Release release_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Hapi.Release.Release Release {
      get { return release_; }
      set {
        release_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as InstallReleaseResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(InstallReleaseResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Release, other.Release)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (release_ != null) hash ^= Release.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (release_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Release);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (release_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Release);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(InstallReleaseResponse other) {
      if (other == null) {
        return;
      }
      if (other.release_ != null) {
        if (release_ == null) {
          release_ = new global::Hapi.Release.Release();
        }
        Release.MergeFrom(other.Release);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            if (release_ == null) {
              release_ = new global::Hapi.Release.Release();
            }
            input.ReadMessage(release_);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// UninstallReleaseRequest represents a request to uninstall a named release.
  /// </summary>
  public sealed partial class UninstallReleaseRequest : pb::IMessage<UninstallReleaseRequest> {
    private static readonly pb::MessageParser<UninstallReleaseRequest> _parser = new pb::MessageParser<UninstallReleaseRequest>(() => new UninstallReleaseRequest());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<UninstallReleaseRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Hapi.Services.Tiller.TillerReflection.Descriptor.MessageTypes[13]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UninstallReleaseRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UninstallReleaseRequest(UninstallReleaseRequest other) : this() {
      name_ = other.name_;
      disableHooks_ = other.disableHooks_;
      purge_ = other.purge_;
      timeout_ = other.timeout_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UninstallReleaseRequest Clone() {
      return new UninstallReleaseRequest(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// Name is the name of the release to delete.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "disable_hooks" field.</summary>
    public const int DisableHooksFieldNumber = 2;
    private bool disableHooks_;
    /// <summary>
    /// DisableHooks causes the server to skip running any hooks for the uninstall.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool DisableHooks {
      get { return disableHooks_; }
      set {
        disableHooks_ = value;
      }
    }

    /// <summary>Field number for the "purge" field.</summary>
    public const int PurgeFieldNumber = 3;
    private bool purge_;
    /// <summary>
    /// Purge removes the release from the store and make its name free for later use.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Purge {
      get { return purge_; }
      set {
        purge_ = value;
      }
    }

    /// <summary>Field number for the "timeout" field.</summary>
    public const int TimeoutFieldNumber = 4;
    private long timeout_;
    /// <summary>
    /// timeout specifies the max amount of time any kubernetes client command can run.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long Timeout {
      get { return timeout_; }
      set {
        timeout_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as UninstallReleaseRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(UninstallReleaseRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (DisableHooks != other.DisableHooks) return false;
      if (Purge != other.Purge) return false;
      if (Timeout != other.Timeout) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (DisableHooks != false) hash ^= DisableHooks.GetHashCode();
      if (Purge != false) hash ^= Purge.GetHashCode();
      if (Timeout != 0L) hash ^= Timeout.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (DisableHooks != false) {
        output.WriteRawTag(16);
        output.WriteBool(DisableHooks);
      }
      if (Purge != false) {
        output.WriteRawTag(24);
        output.WriteBool(Purge);
      }
      if (Timeout != 0L) {
        output.WriteRawTag(32);
        output.WriteInt64(Timeout);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (DisableHooks != false) {
        size += 1 + 1;
      }
      if (Purge != false) {
        size += 1 + 1;
      }
      if (Timeout != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Timeout);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(UninstallReleaseRequest other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.DisableHooks != false) {
        DisableHooks = other.DisableHooks;
      }
      if (other.Purge != false) {
        Purge = other.Purge;
      }
      if (other.Timeout != 0L) {
        Timeout = other.Timeout;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            DisableHooks = input.ReadBool();
            break;
          }
          case 24: {
            Purge = input.ReadBool();
            break;
          }
          case 32: {
            Timeout = input.ReadInt64();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// UninstallReleaseResponse represents a successful response to an uninstall request.
  /// </summary>
  public sealed partial class UninstallReleaseResponse : pb::IMessage<UninstallReleaseResponse> {
    private static readonly pb::MessageParser<UninstallReleaseResponse> _parser = new pb::MessageParser<UninstallReleaseResponse>(() => new UninstallReleaseResponse());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<UninstallReleaseResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Hapi.Services.Tiller.TillerReflection.Descriptor.MessageTypes[14]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UninstallReleaseResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UninstallReleaseResponse(UninstallReleaseResponse other) : this() {
      Release = other.release_ != null ? other.Release.Clone() : null;
      info_ = other.info_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UninstallReleaseResponse Clone() {
      return new UninstallReleaseResponse(this);
    }

    /// <summary>Field number for the "release" field.</summary>
    public const int ReleaseFieldNumber = 1;
    private global::Hapi.Release.Release release_;
    /// <summary>
    /// Release is the release that was marked deleted.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Hapi.Release.Release Release {
      get { return release_; }
      set {
        release_ = value;
      }
    }

    /// <summary>Field number for the "info" field.</summary>
    public const int InfoFieldNumber = 2;
    private string info_ = "";
    /// <summary>
    /// Info is an uninstall message
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Info {
      get { return info_; }
      set {
        info_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as UninstallReleaseResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(UninstallReleaseResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Release, other.Release)) return false;
      if (Info != other.Info) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (release_ != null) hash ^= Release.GetHashCode();
      if (Info.Length != 0) hash ^= Info.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (release_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Release);
      }
      if (Info.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Info);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (release_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Release);
      }
      if (Info.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Info);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(UninstallReleaseResponse other) {
      if (other == null) {
        return;
      }
      if (other.release_ != null) {
        if (release_ == null) {
          release_ = new global::Hapi.Release.Release();
        }
        Release.MergeFrom(other.Release);
      }
      if (other.Info.Length != 0) {
        Info = other.Info;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            if (release_ == null) {
              release_ = new global::Hapi.Release.Release();
            }
            input.ReadMessage(release_);
            break;
          }
          case 18: {
            Info = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// GetVersionRequest requests for version information.
  /// </summary>
  public sealed partial class GetVersionRequest : pb::IMessage<GetVersionRequest> {
    private static readonly pb::MessageParser<GetVersionRequest> _parser = new pb::MessageParser<GetVersionRequest>(() => new GetVersionRequest());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<GetVersionRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Hapi.Services.Tiller.TillerReflection.Descriptor.MessageTypes[15]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetVersionRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetVersionRequest(GetVersionRequest other) : this() {
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetVersionRequest Clone() {
      return new GetVersionRequest(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as GetVersionRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(GetVersionRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(GetVersionRequest other) {
      if (other == null) {
        return;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
        }
      }
    }

  }

  public sealed partial class GetVersionResponse : pb::IMessage<GetVersionResponse> {
    private static readonly pb::MessageParser<GetVersionResponse> _parser = new pb::MessageParser<GetVersionResponse>(() => new GetVersionResponse());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<GetVersionResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Hapi.Services.Tiller.TillerReflection.Descriptor.MessageTypes[16]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetVersionResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetVersionResponse(GetVersionResponse other) : this() {
      Version = other.version_ != null ? other.Version.Clone() : null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetVersionResponse Clone() {
      return new GetVersionResponse(this);
    }

    /// <summary>Field number for the "Version" field.</summary>
    public const int VersionFieldNumber = 1;
    private global::Hapi.Version.Version version_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Hapi.Version.Version Version {
      get { return version_; }
      set {
        version_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as GetVersionResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(GetVersionResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Version, other.Version)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (version_ != null) hash ^= Version.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (version_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Version);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (version_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Version);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(GetVersionResponse other) {
      if (other == null) {
        return;
      }
      if (other.version_ != null) {
        if (version_ == null) {
          version_ = new global::Hapi.Version.Version();
        }
        Version.MergeFrom(other.Version);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            if (version_ == null) {
              version_ = new global::Hapi.Version.Version();
            }
            input.ReadMessage(version_);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// GetHistoryRequest requests a release's history.
  /// </summary>
  public sealed partial class GetHistoryRequest : pb::IMessage<GetHistoryRequest> {
    private static readonly pb::MessageParser<GetHistoryRequest> _parser = new pb::MessageParser<GetHistoryRequest>(() => new GetHistoryRequest());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<GetHistoryRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Hapi.Services.Tiller.TillerReflection.Descriptor.MessageTypes[17]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetHistoryRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetHistoryRequest(GetHistoryRequest other) : this() {
      name_ = other.name_;
      max_ = other.max_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetHistoryRequest Clone() {
      return new GetHistoryRequest(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// The name of the release.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "max" field.</summary>
    public const int MaxFieldNumber = 2;
    private int max_;
    /// <summary>
    /// The maximum number of releases to include.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Max {
      get { return max_; }
      set {
        max_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as GetHistoryRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(GetHistoryRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (Max != other.Max) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (Max != 0) hash ^= Max.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (Max != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(Max);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (Max != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Max);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(GetHistoryRequest other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.Max != 0) {
        Max = other.Max;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            Max = input.ReadInt32();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// GetHistoryResponse is received in response to a GetHistory rpc.
  /// </summary>
  public sealed partial class GetHistoryResponse : pb::IMessage<GetHistoryResponse> {
    private static readonly pb::MessageParser<GetHistoryResponse> _parser = new pb::MessageParser<GetHistoryResponse>(() => new GetHistoryResponse());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<GetHistoryResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Hapi.Services.Tiller.TillerReflection.Descriptor.MessageTypes[18]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetHistoryResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetHistoryResponse(GetHistoryResponse other) : this() {
      releases_ = other.releases_.Clone();
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetHistoryResponse Clone() {
      return new GetHistoryResponse(this);
    }

    /// <summary>Field number for the "releases" field.</summary>
    public const int ReleasesFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Hapi.Release.Release> _repeated_releases_codec
        = pb::FieldCodec.ForMessage(10, global::Hapi.Release.Release.Parser);
    private readonly pbc::RepeatedField<global::Hapi.Release.Release> releases_ = new pbc::RepeatedField<global::Hapi.Release.Release>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Hapi.Release.Release> Releases {
      get { return releases_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as GetHistoryResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(GetHistoryResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!releases_.Equals(other.releases_)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= releases_.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      releases_.WriteTo(output, _repeated_releases_codec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += releases_.CalculateSize(_repeated_releases_codec);
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(GetHistoryResponse other) {
      if (other == null) {
        return;
      }
      releases_.Add(other.releases_);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            releases_.AddEntriesFrom(input, _repeated_releases_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// TestReleaseRequest is a request to get the status of a release.
  /// </summary>
  public sealed partial class TestReleaseRequest : pb::IMessage<TestReleaseRequest> {
    private static readonly pb::MessageParser<TestReleaseRequest> _parser = new pb::MessageParser<TestReleaseRequest>(() => new TestReleaseRequest());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TestReleaseRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Hapi.Services.Tiller.TillerReflection.Descriptor.MessageTypes[19]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TestReleaseRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TestReleaseRequest(TestReleaseRequest other) : this() {
      name_ = other.name_;
      timeout_ = other.timeout_;
      cleanup_ = other.cleanup_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TestReleaseRequest Clone() {
      return new TestReleaseRequest(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// Name is the name of the release
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "timeout" field.</summary>
    public const int TimeoutFieldNumber = 2;
    private long timeout_;
    /// <summary>
    /// timeout specifies the max amount of time any kubernetes client command can run.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long Timeout {
      get { return timeout_; }
      set {
        timeout_ = value;
      }
    }

    /// <summary>Field number for the "cleanup" field.</summary>
    public const int CleanupFieldNumber = 3;
    private bool cleanup_;
    /// <summary>
    /// cleanup specifies whether or not to attempt pod deletion after test completes
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Cleanup {
      get { return cleanup_; }
      set {
        cleanup_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TestReleaseRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TestReleaseRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (Timeout != other.Timeout) return false;
      if (Cleanup != other.Cleanup) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (Timeout != 0L) hash ^= Timeout.GetHashCode();
      if (Cleanup != false) hash ^= Cleanup.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (Timeout != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(Timeout);
      }
      if (Cleanup != false) {
        output.WriteRawTag(24);
        output.WriteBool(Cleanup);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (Timeout != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Timeout);
      }
      if (Cleanup != false) {
        size += 1 + 1;
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TestReleaseRequest other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.Timeout != 0L) {
        Timeout = other.Timeout;
      }
      if (other.Cleanup != false) {
        Cleanup = other.Cleanup;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            Timeout = input.ReadInt64();
            break;
          }
          case 24: {
            Cleanup = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// TestReleaseResponse represents a message from executing a test
  /// </summary>
  public sealed partial class TestReleaseResponse : pb::IMessage<TestReleaseResponse> {
    private static readonly pb::MessageParser<TestReleaseResponse> _parser = new pb::MessageParser<TestReleaseResponse>(() => new TestReleaseResponse());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TestReleaseResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Hapi.Services.Tiller.TillerReflection.Descriptor.MessageTypes[20]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TestReleaseResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TestReleaseResponse(TestReleaseResponse other) : this() {
      msg_ = other.msg_;
      status_ = other.status_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TestReleaseResponse Clone() {
      return new TestReleaseResponse(this);
    }

    /// <summary>Field number for the "msg" field.</summary>
    public const int MsgFieldNumber = 1;
    private string msg_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Msg {
      get { return msg_; }
      set {
        msg_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "status" field.</summary>
    public const int StatusFieldNumber = 2;
    private global::Hapi.Release.TestRun.Types.Status status_ = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Hapi.Release.TestRun.Types.Status Status {
      get { return status_; }
      set {
        status_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TestReleaseResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TestReleaseResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Msg != other.Msg) return false;
      if (Status != other.Status) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Msg.Length != 0) hash ^= Msg.GetHashCode();
      if (Status != 0) hash ^= Status.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Msg.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Msg);
      }
      if (Status != 0) {
        output.WriteRawTag(16);
        output.WriteEnum((int) Status);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Msg.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Msg);
      }
      if (Status != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Status);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TestReleaseResponse other) {
      if (other == null) {
        return;
      }
      if (other.Msg.Length != 0) {
        Msg = other.Msg;
      }
      if (other.Status != 0) {
        Status = other.Status;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Msg = input.ReadString();
            break;
          }
          case 16: {
            status_ = (global::Hapi.Release.TestRun.Types.Status) input.ReadEnum();
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
